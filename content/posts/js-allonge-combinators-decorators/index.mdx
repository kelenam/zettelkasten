---
title: Combinators and Function Decorators | JavaScript Allong√©
date: 2020-01-01
slug: js-allonge-combinators-decorators
tags:
  - JS
  - const 
  - functions 
  - Reg Braithwaite
---

## higher-order functions

>- [^ **What is a higher-order function?**]
As we‚Äôve seen, JavaScript functions take values as arguments and return values. JavaScript functions are values, so JavaScript functions can take functions as arguments, return functions, or both. **Generally speaking, a function that either takes functions as arguments, or returns a function, or both, is referred to as a** [**‚Äúhigher-order‚Äù function**]().

Here‚Äôs a very simple higher-order function that takes a function as an argument:
```js 
const repeat = (num, fn) =>
  (num > 0)
    ? (repeat(num - 1, fn), fn(num))
    : undefined

repeat(3, function (n) {
  console.log(`Hello ${n}`)
})
  //=>
    'Hello 1'
    'Hello 2'
    'Hello 3'
    undefined
``` 
Note: This took me awhile to decipher. What is

Why would `undefined` be listed last if everything else is in the recursive order. Shouldn't `undefined` be printed first? Well if we instead, wrap the `undefined` ternary case like so `fn(undefined)` You'll see that "Hello undefined" will be printed first. So for each recursive function that is called, the first 

`(repeat(num - 1), fn), fn(num)`

- on first glance there is a lot to unpack
  - ternary operator 
  - comma operator
  - recursion 
  - why was I tripped up on needing to pass fn as the second parameter to the recursive function?
    - `fn` creates the binding that lets us use the function that gets passed in as an argument,
    - the first execution of `repeat` would have this binding to fn, but subsequent recursive calls wouldn't know what fn was so when we call it by name on the right hand side of the comma, fn isn't defined on that first recursive call.

- Remember, the comma operator, does the first operation on the left, then it evalutes and returns the expression on the right. 
```js
let x = 1;

x = (x++, x);
// 2 

let fun;
fun = ((() => { console.log('do some side effect')})(), () => { return 'hi'})
```

Higher-order functions dominate JavaScript Allong√©. But before we go on, we‚Äôll talk about some specific types of higher-order functions.

## combinators

The word ‚Äúcombinator‚Äù has a precise technical meaning in mathematics:

    ‚ÄúA combinator is a higher-order function that uses only 
    function application and earlier defined combinators to
    define a result from its arguments.‚Äù
                                          ‚ÄìWikipedia

If we were learning _Combinatorial Logic_, we‚Äôd start with the most basic combinators like S, K, and I, and work up from there to practical combinators. We‚Äôd learn that the fundamental combinators are named after birds following the example of Raymond Smullyan‚Äôs famous book To Mock a Mockingbird.

>- [^ **What is the looser definition of combinator that will be useful for us to know?**]In this book, we will be using a looser definition of ‚Äú[**combinator**]():‚Äù Higher-order pure functions that take only functions as arguments and return a function. We won‚Äôt be strict about using only previously defined combinators in their construction.

>- [^ **What is the Compose combinator? What is another name for it?**]
Let‚Äôs start with a useful combinator: Most programmers call it [**Compose**](), although the logicians call it the [**B combinator or ‚ÄúBluebird.‚Äù**]() Here is the typical programming implementation:
```js 
const compose = (a, b) =>
  (c) => a(b(c))
``` 
Let‚Äôs say we have:
```js 
const addOne = (number) => number + 1;

const doubleOf = (number) => number * 2;
``` 
With `compose`, anywhere you would write
```js 
const doubleOfAddOne = (number) => doubleOf(addOne(number));
``` 
You could also write:
```js 
const doubleOfAddOne = compose(doubleOf, addOne);
``` 
This is, of course, just one example of many. You‚Äôll find lots more perusing the recipes in this book. While some programmers believe ‚ÄúThere Should Only Be One Way To Do It,‚Äù having combinators available as well as explicitly writing things out with lots of symbols and keywords has some advantages when used judiciously.

## a balanced statement about combinators

Code that uses a lot of combinators tends to name the verbs and adverbs (like `doubleOf`, `addOne`, and `compose`) while avoiding language keywords and the names of nouns (like `number`). So one perspective is that combinators are useful when you want to emphasize what you‚Äôre doing and how it fits together, and more explicit code is useful when you want to emphasize what you‚Äôre working with.

## function decorators

>- [**What is a function decorator?**]A [**function decorator**]() is a higher-order function that takes one function as an argument, returns another function, and the returned function is a variation of the argument function. Here‚Äôs a ridiculously simple decorator
```js 
const not = (fn) => (x) => !fn(x)
``` 
So instead of writing `!someFunction(42)`, we can write `not(someFunction)(42)`. Hardly progress. But like `compose`, we could write either:
```js 
const something = (x) => x != null;
``` 
And elsewhere, write:
```js 
const nothing = (x) => !something(x);
``` 
Or we could write:
```js 
const nothing = not(something);
``` 

`not` is a function decorator because it modifies a function while remaining strongly related to the original function‚Äôs semantics. You‚Äôll see other function decorators in the recipes, like `once` and `maybe`. _Function decorators aren‚Äôt strict about being pure functions, so there‚Äôs more latitude for making decorators than combinators_.

## Key Insights 
- [**higher-order functions**](): either take in a function as argument, return a function, or both. 
- [**combinators**](): They are higher-order functions that acccept only funtions as arguments and return a function.
-  [**function decorators**](): higher-order function that takes one function as an argument, returns another function, and the returned function is a variation of the argument function.

## Links 
- [üè† MAIN](/js-allonge-main) 
- [PREV ‚¨Ö | Naming Functions ](/js-allonge-naming-functions )
- [NEXT ‚û° |  Building Blocks ](/js-allonge-building-blocks)

## Summary Questions  
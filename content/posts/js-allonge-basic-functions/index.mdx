---
title: The first sip; Basic Functions | JavaScript AllongÃ©
date: 2020-01-01
slug: js-allonge-basic-functions 
tags:
  - JS
  - Reg Braithwaite
---
**In JavaScript, functions are values**, but they are also much more than simple numbers, strings, or even complex data structures like trees or maps. **Functions represent computations to be performed.**
```js 
() => 0
``` 

This is a function that is applied to no values and returns `0`. Letâ€™s verify that our function is a value like all others:
```js 
(() => 0)
  //=> [Function]
``` 
What!? Why didnâ€™t it type back` () => 0` for us? *This seems to break our rule that if an expression is also a value, JavaScript will give the same value back to us. Whatâ€™s going on?* The simplest and easiest answer is that although the JavaScript interpreter does indeed return that value, displaying it on the screen is a slightly different matter. `[Function]` is a choice made by the people who wrote Node.js, the JavaScript environment that hosts the JavaScript REPL. If you try the same thing in a browser, you may see something else.

## functions and identities
You recall that we have two types of values with respect to identity: **Value types** and **reference types**. Value types share the same identity if they have the same contents. Reference types do not.

Which kind are functions? Letâ€™s try them out and see. For reasons of appeasing the JavaScript parser, weâ€™ll enclose our functions in parentheses:
```js 
(() => 0) === (() => 0)
  //=> false
``` 
- **Like arrays, every time you evaluate an expression to produce a function, you get a new function that is not identical to any other function, even if you use the same expression to generate it**. 
- â€œFunctionâ€ is a reference type.

## applying functions
Letâ€™s put functions to work. The way we use functions is to *apply* them to zero or more values called **arguments**. Just as `2 + 2` produces a value (in this case 4), applying a function to zero or more arguments produces a value as well.

Hereâ€™s how we apply a function to some values in JavaScript: Letâ€™s say that `fn_expr` is an expression that when evaluated, produces a function. Letâ€™s call the arguments args. Hereâ€™s how to apply a function to some arguments:

`fn_expr(args)`

Right now, we only know about one such expression: `() => 0`, so letâ€™s use it. Weâ€™ll put it in parentheses5 to keep the parser happy, like we did above: `(() => 0)`. Since we arenâ€™t giving it any arguments, weâ€™ll simply write () after the expression. So we write:

```js 
(() => 0)()
//=> 0
```

## functions that return values and evaluate expressions
Weâ€™ve seen `() => 0`. We know that `(() => 0)()` returns 0, and this is unsurprising. Likewise, the following all ought to be obvious:

```js 
(() => 1)()
  //=> 1
(() => "Hello, JavaScript")()
  //=> "Hello, JavaScript"
(() => Infinity)()
  //=> Infinity
``` 
Well, the last oneâ€™s a doozy, but still, the general idea is this: **We can make a function that returns a value by putting the value to the right of the arrow**.

In the prelude, we looked at expressions. Values like `0` are expressions, as are things like `40 + 2`. Can we put an expression to the right of the arrow?
```js 
(() => 1 + 1)()
  //=> 2
(() => "Hello, " + "JavaScript")()
  //=> "Hello, JavaScript"
(() => Infinity * Infinity)()
  //=> Infinity
```
Yes we can. We can put any expression to the right of the arrow. For example, `(() => 0)()` is an expression. Can we put it to the right of an arrow, like this: `() => (() => 0)()`?

Letâ€™s try it:
```js 
(() => (() => 0)())()
//=> 0
``` 
Yes we can! **Functions can return the value of evaluating another function**.

When dealing with expressions that have a lot of the same characters (like parentheses), you may find it helpful to format the code to make things stand out. So we can also write:
```js 
(() =>
    (() => 0
      )()
  )()
  //=> 0
```
It evaluates to the same thing, `0`.

## commas
> The [**comma operator**]() in JavaScript is interesting. It takes two arguments, evaluates them both, and itself evaluates to the value of the right-hand argument. In other words:
```js 
(1, 2)
  //=> 2

(1 + 1, 2 + 2)
  //=> 4
``` 
We can use commas with functions to create functions that evaluate multiple expressions:
```js 
(() => (1 + 1, 2 + 2))()
  //=> 4
``` 

> This is useful when trying to do things that might involve side-effects, but weâ€™ll get to that later. In most cases, JavaScript does not care whether things are separated by spaces, tabs, or line breaks. So we can also write:

```js 
() =>
  (1 + 1, 2 + 2)
```
Or even:
```js 
() => (
    1 + 1,
    2 + 2
  )
``` 

## the simplest possible block
Thereâ€™s another thing we can put to the right of an arrow, a block. A [**block**]() has zero or more statements, separated by semicolons. 

So, this is a valid function:
```js 
() => {}
```

It returns the result of evaluating a block that has no statements. What would that be? Letâ€™s try it:
```js 
(() => {})()
  //=> undefined
```
What is this `undefined`?

## `undefined`
> In JavaScript, the absence of a value is written [**`undefined`**](), and it means there is no value. It will crop up again. undefined is its own type of value, and it acts like a value type:
```js 
undefined
  //=> undefined
``` 
Like numbers, booleans and strings, JavaScript can print out the value `undefined`.
```js 
undefined === undefined
  //=> true
(() => {})() === (() => {})()
  //=> true
(() => {})() === undefined
  //=> true
``` 
> No matter how you evaluate `undefined`, you get an identical value back. `undefined` is a value that means â€œI donâ€™t have a value.â€ But itâ€™s still a value.

> You might think that `undefined` in JavaScript is equivalent to NULL in SQL. No. In SQL, two things that are NULL are not equal to nor share the same identity, because two unknowns canâ€™t be equal. In JavaScript, every `undefined` is identical to every other `undefined`.

## void
Weâ€™ve seen that JavaScript represents an undefined value by typing `undefined`, and weâ€™ve generated `undefined` values in two ways:

By evaluating a function that doesnâ€™t return a value `(() => {})()`, and;
By writing undefined ourselves.
Thereâ€™s a third way, with JavaScriptâ€™s void operator. Behold:
```js 
void 0
  //=> undefined
void 1
  //=> undefined
void (2 + 2)
  //=> undefined
```
void is an operator that takes any value and evaluates to undefined, always. So, when we deliberately want an undefined value, should we use the first, second, or third form?7 The answer is, use void. By convention, use void 0.

The first form works but itâ€™s cumbersome. The second form works most of the time, but it is possible to break it by reassigning undefined to a different value, something weâ€™ll discuss in Reassignment and Mutation. The third form is guaranteed to always work, so thatâ€™s what we will use.8

## back on the block
Back to our function. We evaluated this:

(() => {})()
  //=> undefined
We said that the function returns the result of evaluating a block, and we said that a block is a (possibly empty) list of JavaScript statements separated by semicolons.9

Something like: { statement1; statement2; statement3; ... ; statementn }

We havenâ€™t discussed these statements. Whatâ€™s a statement?

There are many kinds of JavaScript statements, but the first kind is one weâ€™ve already met. An expression is a JavaScript statement. Although they arenâ€™t very practical, these are valid JavaScript functions, and they return undefined when applied:

() => { 2 + 2 }
() => { 1 + 1; 2 + 2 }
As we saw with commas above, we can rearrange these functions onto multiple lines when we feel its more readable that way:

() => {
    1 + 1;
    2 + 2
  }
But no matter how we arrange them, a block with one or more expressions still evaluates to undefined:

(() => { 2 + 2 })()
  //=> undefined
  
(() => { 1 + 1; 2 + 2 })()
  //=> undefined
  
(() => {
    1 + 1;
    2 + 2
  })()
  //=> undefined
As you can see, a block with one expression does not behave like an expression, and a block with more than one expression does not behave like an expression constructed with the comma operator:

(() => 2 + 2)()
  //=> 4
(() => { 2 + 2 })()
  //=> undefined
  
(() => (1 + 1, 2 + 2))()
  //=> 4
(() => { 1 + 1; 2 + 2 })()
  //=> undefined
So how do we get a function that evaluates a block to return a value when applied? With the return keyword and any expression:

(() => { return 0 })()
  //=> 0
  
(() => { return 1 })()
  //=> 1
  
(() => { return 'Hello ' + 'World' })()
  // 'Hello World'
The return keyword creates a return statement that immediately terminates the function application and returns the result of evaluating its expression. For example:

(() => {
    1 + 1;
    return 2 + 2
  })()
  //=> 4
And also:

(() => {
    return 1 + 1;
    2 + 2
  })()
  //=> 2
The return statement is the first statement weâ€™ve seen, and it behaves differently than an expression. For example, you canâ€™t use one as the expression in a simple function, because it isnâ€™t an expression:

(() => return 0)()
  //=> ERROR
Statements belong inside blocks and only inside blocks. Some languages simplify this by making everything an expression, but JavaScript maintains this distinction, so when learning JavaScript we also learn about statements like function declarations, for loops, if statements, and so forth. Weâ€™ll see a few more of these later.

## functions that evaluate to functions
If an expression that evaluates to a function is, well, an expression, and if a return statement can have any expression on its right sideâ€¦ Can we put an expression that evaluates to a function on the right side of a function expression?

Yes:

() => () => 0
Thatâ€™s a function! Itâ€™s a function that when applied, evaluates to a function that when applied, evaluates to 0. So we have a function, that returns a function, that returns zero. Likewise:

() => () => true
Thatâ€™s a function, that returns a function, that returns true:

(() => () => true)()()
  //=> true
We could, of course, do the same thing with a block if we wanted:

() => () => { return true; }
But we generally donâ€™t.

## Links 
- [ğŸ  MAIN](/js-allonge-main) 
- [PREV â¬… | A Rich Aroma: Basic Numbers ](/js-allonge-basic-numbers)
- [NEXT â¡ | The first sip: Basic Functions ](/js-allonge-basic-functions)

## Summary Questions 

```js 
/*
    sayHello should return "hello",
    it should return type string 
*/

/* 
    addNumbers should return a number,
    it should be greater than 5 if args
    (5,5) are passed in 
*/ 
```
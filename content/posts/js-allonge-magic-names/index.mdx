---
title: Magic Names | JavaScript Allong√©
date: 2020-01-01
slug:  js-allonge-magic-names 
tags:
  - JS
  - const 
  - functions 
  - Reg Braithwaite
---

>- [^ **What happens with regards to argument binding when a function is called?**]When a function is applied to arguments (or ‚Äúcalled‚Äù), JavaScript binds the values of arguments to the function‚Äôs argument names in an environment created for the function‚Äôs execution. What we haven‚Äôt discussed so far is that JavaScript also binds values to some ‚Äúmagic‚Äù names in addition to any you put in the argument list.

## the function keyword

There are two separate rules for these ‚Äúmagic‚Äù names, one for when you invoke a function using the function keyword, and another for functions defined with ‚Äúfat arrows.‚Äù We‚Äôll begin with how things work for functions defined with the `function` keyword.

The first magic name is `this`, and it is bound to something called the function‚Äôs [**context**](). We will explore this in more detail when we start discussing objects and classes. The second magic name is very interesting, it‚Äôs called `arguments`, and the most interesting thing about it is that it contains a list of arguments passed to a function:
```js 
const plus = function (a, b) {
  return arguments[0] + arguments[1];
}

plus(2,3)
  //=> 5
```

>- [^ **What is interesting about the `arguments` keyword?**]Although `arguments` looks like an array, it isn‚Äôt an array: It‚Äôs more like an object that happens to bind some values to properties with names that look like integers starting with zero:

```js 
const args = function (a, b) {
  return arguments;
}

args(2,3)
  //=> { '0': 2, '1': 3 }
```

`arguments` always contains all of the arguments passed to a function, regardless of how many are declared. Therefore, we can write `plus` like this:
```js 
const plus = function () {
  return arguments[0] + arguments[1];
}

plus(2,3)
  //=> 5
``` 
When discussing objects, we‚Äôll discuss properties in more depth. Here‚Äôs something interesting about arguments:
```js
const howMany = function () {
  return arguments['length'];
}

howMany()
  //=> 0

howMany('hello')
  //=> 1

howMany('sharks', 'are', 'apex', 'predators')
  //=> 4
``` 
The most common use of the `arguments` binding is to build functions that can take a variable number of arguments. We‚Äôll see it used in many of the recipes, starting off with *partial application* and *ellipses*.

## magic names and fat arrows

>- [^ **How is the binding for fat arrow functions different from functions declared with the `function` keyword?**]
The magic names `this` and arguments have a different behaviour when you invoke a function that was defined with a fat arrow: **Instead of being bound when the function is invoked, the fat arrow function always acquires the bindings for `this` and `arguments` from its enclosing scope, just like any other binding.**

For example, when this expression‚Äôs inner function is defined with `function`, `arguments[0]` refers to its only argument, `"inner"`:
```js 
(function () {
  return (function () { return arguments[0]; })('inner');
})('outer')
  //=> "inner"
``` 
But if we use a fat arrow, arguments will be defined in the outer environment, the one defined with function. And thus `arguments[0]` will refer to `"outer"`, not to `"inner"`:
```js 
(function () {
  return (() => arguments[0])('inner');
})('outer')
  //=> "outer"
``` 
Although it seems quixotic for the two syntaxes to have different semantics, it makes sense when you consider the design goal: **Fat arrow functions are designed to be very lightweight and are often used with constructs like mapping or callbacks to emulate syntax.**

To give a contrived example, this function takes a number and returns an array representing a row in a hypothetical multiplication table. It uses `mapWith`, which we discussed in Building Blocks. We‚Äôll use arguments just to show the difference between using a fat arrow and the `function` keyword:
```js 
const row = function () {
  return mapWith((column) => column * arguments[0])(
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
  )
}

row(3)
  //=> [3,6,9,12,15,18,21,24,27,30,33,36
```
This works just fine, because `arguments[0]` refers to the `3` we passed to the function row. Our ‚Äúfat arrow‚Äù function` (column) => column * arguments[0]` doesn‚Äôt bind `arguments` when it‚Äôs invoked. But if we rewrite row to use the `function` keyword, it stops working:
```js  
const row = function () {
  return mapWith(function (column) { return column * arguments[0] })(
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
  )
}

row(3)
  //=> [1,4,9,16,25,36,49,64,81,100,121,144]
```
Now our `inner` function binds `arguments[0]` every time it is invoked, so we get the same result as if we‚Äôd written `function (column) { return column * column }`.

>- [^ **What might we mean when we refer to a function as a Big-F function? What about a small-f function?**]
Although this example is clearly unrealistic, there is a general design principle that deserves attention. Sometimes, a function is meant to be used as a Big-F function. It has a name, it is called by different pieces of code, it‚Äôs a first-class entity in the code.

But sometimes, a function is a small-f function. It‚Äôs a simple representation of an expression to be computed. In our example above, `row` is a Big-F function, but `(column) => column * arguments[0]` is a small-f function, it exists just to give `mapWith` something to apply.

**Having magic variables apply to Big-F functions but not to small-f functions makes it much easier to use small-f functions as syntax, treating them as expressions or blocks that can be passed to functions like `mapWith`.**

## Summary
### Functions
- Functions are values that can be part of expressions, returned from other functions, and so forth.
- Functions are reference values.
- Functions are applied to arguments.
- The arguments are passed by sharing, which is also called ‚Äúpass by value.‚Äù
- Fat arrow functions have expressions or blocks as their bodies.
- `function` keyword functions always have blocks as their bodies.
- Function bodies have zero or more statements.
- Expression bodies evaluate to the value of the expression.
- Block bodies evaluate to whatever is returned with the `return` keyword, or to `undefined`.
- JavaScript uses `const` to bind values to names within block scope.
- JavaScript uses function declarations to bind functions to names within function scope. Function declarations are ‚Äúhoisted.‚Äù
- Function application creates a scope.
- Blocks also create scopes if `const` statements are within them.
- Scopes are nested and free variable references closed over.
- Variables can shadow variables in an enclosing scope.

## Key Insights 
- It's kind of a mental flip for me to think of functions as being applied to arguments, but this seems like a common approach throughout this text. 

## Links 
- [üè† MAIN](/js-allonge-main) 
- [PREV ‚¨Ö | Building Blocks ](/js-allonge-building-blocks)
- [NEXT ‚û° | Partial Application ](/js-allonge-partial-application)

## Summary Questions  
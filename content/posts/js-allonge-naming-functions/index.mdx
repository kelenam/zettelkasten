---
title: Naming Functions | JavaScript Allong√©
date: 2020-01-01
slug: js-allonge-naming-functions 
tags:
  - JS
  - const 
  - functions 
  - Reg Braithwaite
---

Let‚Äôs get right to it. This code does not name a function:
```js
const repeat = (str) => str + str
``` 
>- [^ **What is going on with regards to naming of the following code: `const repeat = (str) => str + str`**]It doesn‚Äôt name the function ‚Äúrepeat‚Äù for the same reason that const answer = 42 doesn‚Äôt name the number 42. This syntax binds an anonymous function to a name in an environment, but the function itself remains anonymous.

## the function keyword
JavaScript does have a syntax for naming a function, we use the `function` keyword. Until ECMAScript 2015 was created, `function` was the usual syntax for writing functions.

>- [^ **What are 5 differences between fat arrow functions and anonymous function declarations doing the same thing?**]Here‚Äôs our `repeat` function written using a ‚Äúfat arrow‚Äù
```js 
(str) => str + str 
``` 
And here‚Äôs (almost) the exact same function written using the `function` keyword:
```js 
function (str) { return str + str }
``` 
Let‚Äôs look at the obvious differences:

1. We introduce a function with the `function` keyword.
2. Something else we‚Äôre about to discuss is optional.
3. We have arguments in parentheses, just like fat arrow functions.
4. We do not have a fat arrow, we go directly to the body.
5. We always use a block, we cannot write `function (str) str + str`. This means that if we want our functions to return a value, we always need to use the `return` keyword

If we leave out the ‚Äúsomething optional‚Äù that comes after the `function` keyword, we can translate all of the fat arrow functions that we‚Äôve seen into `function` keyword functions, e.g.
```js 
(n) => (1.618**n - -1.618**-n) / 2.236
```

Can be written as:
```js 
function (n) {
  return (1.618**n - -1.618**-n) / 2.236;
}
``` 
This still does not name a function, but as we noted above, functions written with the `function` keyword have an optional ‚Äúsomething else.‚Äù Could that ‚Äúsomething else‚Äù name a function? Yes, of course.

Here are our example functions written with names:
```js 
const repeat = function repeat (str) {
  return str + str;
};

const fib = function fib (n) {
  return (1.618**n - -1.618**-n) / 2.236;
};
``` 
>- [^ **What does placing a name between the function keyword and the argument list do?**]Placing a name between the `function` keyword and the argument list names the function. Confusingly, the name of the function is not exactly the same thing as the name we may choose to bind to the value of the function. For example, we can write:
```js
const double = function repeat (str) {
  return str + str;

```
>- [**‚≠êWhat is happening when we say `const double = function repeat (str) {...}`**]‚≠êIn this expression, `double` is the name in the environment, but `repeat` is the function‚Äôs actual name. This is a [**named function expression**](). That may seem confusing, but think of the binding names as properties of the environment, not of the function. While the name of the function is a property of the function, not of the environment.

And indeed the name is a property:
```js 
double.name
  //=> 'repeat'
```
In this book we are not examining JavaScript‚Äôs tooling such as debuggers baked into browsers, but we will note that when you are navigating call stacks in all modern tools, the function‚Äôs binding name is ignored but its actual name is displayed, so naming functions is very useful even if they don‚Äôt get a formal binding, e.g.
```js
someBackboneView.on('click', function clickHandler () {
  //...
});
```
Now, the function‚Äôs actual name has no effect on the environment in which it is used. To whit:
```js 
const bindingName = function actualName () {
  //...
};

bindingName
  //=> [Function: actualName]

actualName
  //=> ReferenceError: actualName is not define
```
>- [****]
So ‚ÄúactualName‚Äù isn‚Äôt bound in the environment where we use the named function expression. Is it bound anywhere else? Yes it is. Here‚Äôs a function that determines whether a positive integer is even or not. We‚Äôll use it in an IIFE so that we don‚Äôt have to bind it to a name with `const`:
```js 
(function even (n) {
  if (n === 0) {
    return true
  }
  else return !even(n - 1)
})(5)
  //=> false

(function even (n) {
  if (n === 0) {
    return true
  }
  else return !even(n - 1)
})(2)
  //=> true
```
Clearly, the name `even` is bound to the function within the function‚Äôs body. Is it bound to the function outside of the function‚Äôs body?
```js 
even
  //=> Can't find variable: even
```
`even` is bound within the function itself, but not outside it. This is useful for making recursive functions as we see above, and it speaks to the principle of least privilege: If you don‚Äôt need to name it anywhere else, you needn‚Äôt.

## function declarations
There is another syntax for naming and/or defining a function. It‚Äôs called a [**function declaration statement**](), and it looks a lot like a named function expression, only we use it as a statement:
```js 
function someName () {
  // ...
}
```
This behaves a little like:
```js 
const someName = function someName () {
  // ...
}
```
In that it binds a name in the environment to a named function. However, there are two important differences. First, function declarations are *hoisted* to the top of the function in which they occur.

Consider this example where we try to use the variable `fizzbuzz` as a function before we bind a function to it with `const`:
```js 
(function () { 
  return fizzbuzz();

  const fizzbuzz = function fizzbuzz () {
    return "Fizz" + "Buzz";
  }
})()
  //=> undefined is not a function (evaluating 'fizzbuzz()')
```
We haven‚Äôt actually bound a function to the name `fizzbuzz` before we try to use it, so we get an error. But a function declaration works differently:
```js 
(function () {
  return fizzbuzz();

  function fizzbuzz () {
    return "Fizz" + "Buzz";
  }
})()
  //=> 'FizzBuzz'
``` 
Although `fizzbuzz` is declared later in the function, JavaScript behaves as if we‚Äôd written:
```js 
(function () {
  const fizzbuzz = function fizzbuzz () {
    return "Fizz" + "Buzz";
  }

  return fizzbuzz();
})()
```
The definition of the `fizzbuzz` is ‚Äúhoisted‚Äù to the top of its enclosing scope (an IIFE in this case). This behaviour is intentional on the part of JavaScript‚Äôs design to facilitate a certain style of programming where you put the main logic up front, and the ‚Äúhelper functions‚Äù at the bottom. It is not necessary to declare functions in this way in JavaScript, but understanding the syntax and its behaviour (especially the way it differs from `const`) is essential for working with production code.

## function declaration caveats
Function declarations are formally only supposed to be made at what we might call the ‚Äútop level‚Äù of a function. Although some JavaScript environments permit the following code, this example is technically illegal and definitely a bad idea:
```js 
(function (camelCase) {
  return fizzbuzz();

  if (camelCase) {
    function fizzbuzz () {
      return "Fizz" + "Buzz";
    }
  }
  else {
    function fizzbuzz () {
      return "Fizz" + "Buzz";
    }
  }
})(true)
  //=> 'FizzBuzz'? Or ERROR: Can't find variable: fizzbuzz?
```
**Function declarations are not supposed to occur inside of blocks**. The big trouble with expressions like this is that they may work just fine in your test environment but work a different way in production. Or it may work one way today and a different way when the JavaScript engine is updated, say with a new optimization.

**Another caveat is that a function declaration cannot exist inside of any expression, otherwise it‚Äôs a function expression.** So this is a function declaration:
```js 
function trueDat () { return true }
But this is not:
```
```js
(function trueDat () { return true })
``` 
The parentheses make this an expression, not a function declaration.

## Key Insights
- difference between a _named function expression_ and a _named function declaration_.
- A function can have both a binding name and a function name. 
- don't use function declarations within conditional blocks. 
-  The caveats of function declarations
  - can't be used in block 
  - cannot exist inside of any expression, otherwise its a function expression.
    - e.g. `(function trueDat () { return true })` 
      - the parentheses make tis an expression not a function declaration. 

## Links 
- [üè† MAIN](/js-allonge-main) 
- [PREV ‚¨Ö | That Constant Coffee Craving ](/js-allonge-constant-craving)
- [NEXT ‚û° | Combinators and Function Decorators](/js-allonge-combinators-decorators)

## Summary Questions  